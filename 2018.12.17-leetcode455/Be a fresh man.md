## 455_(分发饼干)Assign Cookies
## 1 问题描述、输入输出与样例
### 1.1 问题描述
假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj >= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

__注意__：
* 你可以假设胃口值为正。
* 一个小朋友最多只能拥有一块饼干。
### 1.2 输入与输出
输入：
* vector< int>& g:孩子胃口尺寸的数组
* vector< int>& s:饼干尺寸的数组

输出：
* int:分发饼干满足孩子的最大数量
### 1.3 样例
#### 1.3.1 样例1
输入: [1,2,3], [1,1]<br>
输出: 1<br>
解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 
#### 1.3.2 样例2
输入: [1,2], [1,2,3]<br>
输出: 2<br>
解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.
## 2 思路描述与代码	
### 2.1 思路描述（贪心法）
1. 对孩子胃口尺寸的数组 g 和饼干尺寸的数组 s 进行排序;
2. 以先分发较小的饼干为原则分发饼干给孩子（贪心原则）

比如输入:g = [1,2], s = [1,2,3]<br>
排序后:  g = [1,2], s = [1,2,3]<br>
先分发s[0]给g[0],再分发s[1]给g[1],可以满足两个孩子，所以输出2
### 2.2 代码
```cpp
//函数中涉及到的c++知识
//vector<int> 是个长度可变的int数组，c++里面称为容器
//ret_func_type func(vector<int>& name) 中的name是vector<int>容器的引用，可以理解为传入一个指针
//sort(g.begin(), g.end()) 对容器g的元素从小到大排序，容器的起始数据的指针是 g.begin(),容器的末尾数据的指针是g.end()

//贪心法
int findContentChildren(vector<int>& g, vector<int>& s) {
    int len_g = g.size();
    int len_s = s.size();
    //先从小到大排序
    sort(g.begin(), g.end());
    sort(s.begin(), s.end());
    //尝试将饼干从小到大分发
    int idx_g = 0, idx_s = 0;
    int cnt_satisfy = 0;
    while( idx_g < len_g && idx_s < len_s ){
        //能满足这个孩子，继续下个饼干发给下一个孩子
        if(g[idx_g] <= s[idx_s]){
            ++cnt_satisfy;
            ++idx_g, ++idx_s;
        }
        //不能满足这个孩子，换个更大的
        else ++idx_s;
    }
    return cnt_satisfy;
}
```
## 3 思考与拓展
### 3.1 思考
本题利用贪心原则(先分发较小的饼干为原则分发饼干给孩子)就能解决该问题。
#### 3.1.1 其他方法
无。
#### 3.1.2 复杂度分析
方法|空间复杂度|时间复杂度
--- | --- | ---
贪心法|O(1)|O(nlogn),n=max(len_g, len_s)
#### 3.1.3 难点分析
1. 找到贪心的原则

### 3.2 拓展
如果改变贪心原则为先分发较大的饼干为原则分发饼干给孩子会不会有问题？有什么问题？
